#heading[Параллелизм.]
#emph[Параллелизм (MIMD, что такое SMT, SIMD, почему GPU это SIMD).]

#import "/commons.typ":imagebox

== Вводная терминология
#emph[Процесс] --- часть программы, запущенная на выполнение. Процессы в общем случае не имеют общего кода и общей памяти. Они достаточно независимы друг от друга.

#emph[Поток] --- наименьшая последовательность инструкций внутри процесса, которой может независимо управлять планировщик. 

#emph[Многоядерный вычислитель] --- несколько вычислительных ядер на одном кристалле процессора. При это L1 кэш уникальный для каждого ядра, L2 уникальный или общий, а L3 - общий для всех.

#emph[Многопроцессорный вычислитель] --- физически несколько процессоров (многоядерных или одноядерных).

== Виды параллельных архитектур (параллелизм по инструкциям и по данным)
+ SISD (Single Instruction stream Single Data stream) - простой одноядерный процессор.
+ SIMD (Single Instruction Multiple Data) - архитектура, характерная для видеокарт и векторных процессоров.
+ MISD (Multiple Instructions Single Data) - не имеет практического применения.
+ MIMD (Miltiple Instructions Multiple-Data) - многоядерный процессор.

=== MIMD
#imagebox("MIMD.png", height: 200pt)
Архитектура MIMD используется для многопроцессорных архитектур общего назначения. При небольшом количестве ядер можно поддерживать работу с памятью в форме модели UMA.

#imagebox("MIMDsec.png", height: 200pt)
При большом количестве вычислителей общую память поддерживать сложно, поэтому используется модель разделения памяти NUMA.

=== SMT и HyperThreading
#emph[SMT (Simultaneous Multithreading / Одновременная многопоточность)] - подход при котором один процессор выполняет несколько потоков операций.

#emph [Hyperthreading] - конкретная реализация SMT от Intel.

#emph[Алгоритм работы]:
+ Каждое ядро может хранить состояние двух потоков, используя два набора регистров и два контроллера прерываний.
+ Количество реальных вычислителей не меняется (один), однако вычислитель постоянно переключается между двумя потоками, которые обрабатывает текущее ядро
+ Данная модель возможна и эффективна при кэш промахах одного из процеесов. Поскольку в данном случае оптимизируется время, потраченное на поиск данных в оперативной памяти (пока один процесс делает запрос, над данными второго начинается работа)

=== SIMD
Векторные процессоры - первые, кто реализовывал архитектуру SIMD. Основное отличие в том, что операндами могут выступать целые массивы данных. Однако векторные процессоры не увенчались успехом, более того, почти все современные микропроцессоры могут производить векторные вычисления (семейство расширений SSE).

=== Почему GPU это SIMD?
#imagebox("fermi.png", height: 200pt)

#grid(columns: (auto, 170pt), column-gutter: 15pt, [
  GPGPU — техника использования графического процессора видеокарты, предназначенного для компьютерной графики, в целях производства математических вычислений, которые обычно проводит центральный процессор. Например, достаточно удобно рассчитывать задачи связанные с машинным обучением, к примеру, перемножение матриц, поскольку в данном случае можно хорошо использовать параллельные вычисления.
  
  На примере архитектуры, представленной выше, у нас есть множество мультипроцессоров, у них у всех есть кэш второго уровня. Видеокарта может одновременно использовать все имеющиеся мультироцессоры, выполняя на каждом разные инструкции. Непосредственно подход SIMD реализуется внутри данных потоковых мультипроцессоров. Смотря на картинку выше, нетрудно описать реализацию, которая состоит в том, что на одном столбце можно выполнить какую-то одну операцию над различными данными.
], imagebox("cuda.png"))

